#lang scheme
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 11)

;                                       (cc 11 5)
;                                         /   \
;                                  (cc 11 4) (cc -39 5)
;                                    /     \         \
;                               (cc 11 3)  (cc -14 4)  0
;                               /       \           \
;                              /         \_____      0
;                             /                \
;                         (cc 11 2)             \________________________________ (cc 1 3)
;                            /    \________                                        /   \ 
;                           /              \                                      /     \
;                    (cc 11 1)       (cc 6 2)                                 (cc 1 2) (cc -9 3)
;                    / \             /      \                                   /   \        \
;                   /   \           /        \______________                   /     \        0
;                  /     \         /                        \                 /       \
;           (cc 10 1) (cc 11 0)  (cc 6 1)                  (cc 1 2)          (cc 1 1)  (cc -4 2)
;             /   \      \        /  \                      /   \              /   \        \
;            /     \      0      /    \                    /     \            /     \        0
;       (cc 10 0) (cc 9 1)   (cc 6 0) (cc 5 1)         (cc 1 1) (cc -4 2) (cc 1 0) (cc 0 1)
;        /             /\       /        /\               /\        \       /         \
;       0             /  \     0        /  \             /  \        0     0           1
;                    /    \            /    \           /    \
;              (cc 9 0) (cc 8 1) (cc 5 0) (cc 4 1) (cc 1 0) (cc 0 1)
;                 /         /\       /       /\       /        \
;                0         /  \     0       /  \     0          1
;                         /    \           /    \
;                   (cc 8 0) (cc 7 1) (cc 4 0) (cc 3 1)
;                        /      /\        /       /\
;                       0      /  \      0       /  \
;                             /    \            /    \
;                       (cc 7 0) (cc 6 1) (cc 3 0) (cc 2 1)
;                          /       /  \       /      /  \
;                         0       /    \     0      /    \
;                           (cc 6 0) (cc 5 1)  (cc 2 0) (cc 1 1)
;                               /       /\        /        /\
;                              0       /  \      0        /  \
;                                (cc 5 0) (cc 4 1)  (cc 1 0) (cc 0 1)
;                                    /       /\         /      \
;                                   0       /  \       0        1
;                                    (cc 4 0) (cc 3 1)
;                                         /       /\
;                                        0       /  \
;                                         (cc 3 0) (cc 2 1)
;                                              /       /\
;                                             0       /  \
;                                              (cc 2 0) (cc 1 1)
;                                                   /       /\
;                                                  0       /  \
;                                                    (cc 1 0) (cc 0 1)
;                                                        /      \
;                                                       0        1
;
;
; Рассчитаем рост числа шагов, необходимых для вычисления количества способов размена. Для вычисления мы используем рекурсию, с увеличением числа amount растет и количество
; отложенных операций. Как мы видим из дерева процесса при (cc 11 1) каждая операция раскладывается на два рекурсивных вызова процедуры cc, одна из которых вычисляется сразу 
; (cc amount 0) = 0, вторая (cc (- amount 1) 1) опять раскладывается на два вызова. Т.е. число шагов для вычисления при kind-of-coins = 1 равно 2*amount + 1, считая с вызовом
; функции (cc 11 1). В случае, когда first-denomination будет возвращать число большее, чем 1, число шагов будет еще меньше, т.к. amount будет уменьшаться быстрее.
; Следовательно при kinds-of-coins = 1 сложность алгоритма по числу шагов 2*amount + 1, f(n) = 2*n +1, порядок роста по числу шагов: O(n). Аналогично будет расти и потребление
; памяти.
; Рассмотрим поведение функции cc при kinds-of-coins = 2. Для упрощения будем считать, что (first-denomination 2) тоже будет возвращать 1. Тогда функция (cc 11 2)
; сделает два рекурсивных вызова, один из которых будет (cc 11 1), а второй (cc 10 2). Функцию (cc 11 1) мы уже рассматривали ранее, функция (cc 10 2) сделает тоже
; два рекурсивных вызова, подобно (cc 11 2). В этом случае количество шагов будет:
;
;                       f(n) = (2*amount + 1)+(2*(amount - 1) + 1)+...+(2*(amount - amount)) + 1) = sum(from: m = 0, to: m = amount)(2*amount + (1 - 2*m))   (1)
;                                                               \_______/
;                                                               amount раз
; Упростим выражение (1) 
;
;                       f(n) = 2*amount*amount + sum(from: m = 0, to: m = amount)(1 - 2*m) = 2*amount^2 + ((2+(-2*(amount-1)))/2)*amount = 3*amount^2
; Следовательно при kinds-of-coins = 2 сложность алгоритма по числу шагов 3*amount^2,  порядок роста по числу шагов: O(n^2)
;
; При kinds-of-coins = 3, так же как и в предыдущем случае опять будет два рекурсивных вызова, но один из вызовов будет с kind-of-coins = 2, соответственно порядок роста будет
; O(n^3), и так далее. Для нашего случая где kind-of-coins = 5 порядок роста по числу шагов соответственно O(n^5).
; Потребление памяти будет расти линейно, т.е. порядок роста O(n), т.к. для вычисления каждого следующего значения нужно будет запоминать только результаты предыдущих операций, 
; соответственно потребление памяти будет зависеть только от глубины нашего дерева. (Аналогично алгоритму для вычисления чисел Фибоначчи из 1.2.2)
