(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))

; При использовании аппликативного порядка вычисления, вначале будут вычисляться значения операндов,
; после чего будет применяться процедура test. Но операнд (p) определен "рекурсивно" в (define (p) (p)),
; поэтому происходит зацикливание и выполнения процедуры test не происходит,
; т.к. невозможно вычислить значение операнда.

; При использовании нормального порядка вычисления, вначале будет выполняться подстановка значений.
; Что на первом шаге для процедуры test даст результат в виде:
;  (if (= 0 0)
;      0
;      (p))
; А т.к. в if первым вычисляется предикат, который определяет какую ветвь вычислять,
; то (p) не вычисляется и процедура вернёт 0
