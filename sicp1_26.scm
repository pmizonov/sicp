#lang scheme

(define (square x)
  (* x x))

(define (even? a)
  (= (remainder a 2) 0))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

; Используя операцию умножения в процедуре expmod вместо вызова square
; время выполнения процедуры становится не O(log n), а O(n). Это связано
; с порядком подстановки, т.к. у нас используется аппликативный порядок, т.е.
; сначала вычисляется аргумент, потом его значение подставляется в процедуру,
; то при исползовании операции умножения вместо square вычисление expmod будет 
; производиться дважды для четных чисел. Если мы используем square, то вычисление 
; будет происходить только один раз.
; Так что процесс вычисления станет вместо линейно-рекурсивного древовидно-рекурсивным.
; Сложность такого процесс будет O(2^n), но т.к. сложность самого алгоритма expmod O(log n)
; общая сложность получается примерно O(n).
